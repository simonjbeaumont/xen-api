Support for 'legacy' option for pre-64 bit suspend images
=========================================================

1. Requirements
-------------------------------------------------------------------------------
* Support resuming 32-bit images on 64-bit hosts
* Support live migration case
* Support RPU case

2. Design
-------------------------------------------------------------------------------
There exists a `--legacy` flag for `xenguest` to handle legacy streams;
Xapi/Xenopsd need to be modified to understand when and when not to use this
option.

2.1. Use cases for `--legacy` flag
----------------------------------
Should be used when:
    1. Restoring from a suspend image created on an old version
    2. Live-migrating from an old version (rolling-pool-upgrade)

2.2. Suspend VDIs
-----------------
2.2.1. Distinguishing legacy suspend VDIs
We need to distinguish between legacy suspend VDIs and new suspend VDIs. Since
the old ones already exist, a simple approach would be to mark new suspend
images as such and assume the absence of such a mark implies a legacy image.
This could be implemented by adding a new field to the VDI record. Something
more expressive than a boolean would be more future proof---if there are
further revisions to come, we won't need to change the datamodel again.

2.2.2. Use this as an opportunity to make suspend images libxl-compatible
There are nested formats in this context:
    i. the format of image for Xenguest to restore the domain from
   ii. the format of the suspend VDI
(i) is contained within (ii) and we'd like to take the opportunity to make (ii)
as generated by Xenopsd (currenly also restored by Xenopsd/libxc) able to be
restored by libxl. This work has already been done (as part of EA-1268) and
exists in the disaggregated xenopsd.git. This will need to be ported back into
the pre-disaggregation xen-api.git/ocaml/xenopsd/ for product branches that do
not use 'upstream' xenopsd. There are also some changes to the Xen patchqueue.
For details on the work done to acheive this and the necessary changesets, see
the design doc (plaintext) in xenopsd.git:
https://github.com/xapi-project/xenopsd/blob/master/doc/suspend-image-considerations.txt.

2.2.3. Use this as an opportunity to use a raw image
Current suspend image VDIs (even after the work in 2.2.2.) have an ext2
filesystem on them containing a file called suspend-image with the data inside.
This is a pain because it means that xenopsd needs to block attach the VDI to
dom0 to mount the filesystem and extract the contents of the suspend-image
file. Instead, we would like to use a raw format on the VDI.

2.3. (Possible) interface changes
---------------------------------
In addition to the Xapi datamodel change in 2.2.1., Xapi needs some mechanism
to tell Xenopsd whether to use the legacy flag or not since it is the latter
who calls Xenguest in the Domain.restore_common function. This function does
already take an `extras` parameter but this is not an exported beyond the
Domain module, let alone the Xenops_interface. It is also hard-set to [] by
pv_restore and hvm_restore. Currently the arguments and type of the public
Domain.restore function are:

    let restore (task: Xenops_task.t) ~xc ~xs info timeoffset xenguest_path domid fd =

    val restore: Xenops_task.Xenops_task.t -> xc: Xenctrl.handle ->
        xs: Xenstore.Xs.xsh -> build_info -> string -> string -> domid ->
        Unix.file_descr -> unit

    type build_info = {
        memory_max: int64;    (* memory max in kilobytes *)
        memory_target: int64; (* memory target in kilobytes *)
        kernel: string;       (* in hvm case, point to hvmloader *)
        vcpus: int;           (* vcpus max *)
        priv: builder_spec_info;
    }

    type builder_spec_info =
        | BuildHVM of build_hvm_info | BuildPV of build_pv_info

    type build_hvm_info = {
        shadow_multiplier: float;
        video_mib: int;
    }

    type build_pv_info = {
        cmdline: string;
        ramdisk: string option;
    }

We have three options:
    1. Adding a typed field to the datatypes in the Xapi/Xenops interface
    2. Adding a untyped key to the (platformdata: (string * string) list)
    3. Adding an extra parameter to the XenopsAPI call

Of these 1. is _not_ desirable because we don't have a clear upgrade of
interfaces for Xenopsd and RPU migration involves Xenopsd -> Xenopsd
communication.

2. and 3. are much the same. There may reasons for choosing one over the other
such as clarity or taste.
